// 102 -> 116 FPS

#include <stdio.h>

#ifdef __ANDROID__
#include "SDL.h"
#include "SDL_image.h"
#include "SDL_mixer.h"
#include "SDL_ttf.h"
#include "SDL_opengles.h"
#define printf(args...)     __android_log_print(4, "SDL", ## args);
#define fprintf(x, args...) __android_log_print(4, "SDL", ## args);
#else
#include "SDL2/SDL.h"
#include "SDL2/SDL_image.h"
#include "SDL2/SDL_mixer.h"
#include "SDL2/SDL_ttf.h"
#include "SDL2/SDL_opengl.h"
#endif

#include <assert.h>
#include <stdint.h>
typedef int64_t  s64;
typedef int32_t  s32;
typedef int16_t  s16;
typedef int8_t    s8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint16_t u16;
typedef uint8_t   u8;

int ret = 0;
int ret_val;
#define ceu_out_end(v) { ret=1; ret_val=v; }


#ifndef _CEU_DEFS_H
#define _CEU_DEFS_H
void ceu_go_init ();
void ceu_go_event (int id, void* data);
void ceu_go_async ();
void ceu_go_wclock (s32 dt);
#define CEU_IN__NONE 0
#define CEU_IN__STK 2
#define CEU_IN__ORG 3
#define CEU_IN__ORG_PSED 4
#define CEU_IN__INIT 5
#define CEU_IN__CLEAR 6
#define CEU_IN__WCLOCK 7
#define CEU_IN__ASYNC 8
#define CEU_IN_SDL_REDRAW 9
#define CEU_IN_SDL_QUIT 10
#define CEU_IN_SDL_DT 11
#define CEU_OUT_n 0
#define CEU_FUN_SDL_SetRenderDrawColor
#define CEU_FUN_printf
#define CEU_FUN_SDL_CreateWindow
#define CEU_FUN_SDL_DestroyRenderer
#define CEU_FUN_SDL_RenderFillRect
#define CEU_FUN_SDL_RenderPresent
#define CEU_FUN_SDL_GetWindowSize
#define CEU_FUN_rand
#define CEU_FUN_SDL_DestroyWindow
#define CEU_FUN_SDL_CreateRenderer
#define CEU_EXTS
#define CEU_ORGS
#define CEU_WCLOCKS
#define CEU_CLEAR
#define CEU_NEWS
#define CEU_GOTO
#endif
s32 WCLOCK_nxt;

#ifndef CEU_IN_SDL_DT
#define ceu_out_wclock(us) WCLOCK_nxt = us;
#endif

#ifdef CEU_ASYNCS
int ASYNC_nxt = 0;
#define ceu_out_async(v) ASYNC_nxt = v;
#endif


/*
 * This file is automatically generated.
 * Check the github repository for a readable version:
 * http://github.com/fsantanna/ceu
 *
 * CÃ©u is distributed under the MIT License:
 *

Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#line 0 "samples/sdl6.ceu"

#include <string.h>
#include <limits.h>

#ifdef CEU_DEBUG
#include <assert.h>
#include <signal.h>
#include <stdlib.h>
#endif

#ifdef CEU_NEWS
#include <stdlib.h>
#endif

#ifdef CEU_NEWS
/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */

typedef struct {
    int     size;
    int     free;
    int     index;
    int     unit;
    char** queue;
    char*  mem;
} tceu_pool;

#define CEU_POOL(name, type, size)    \
    static type* name##_queue[size];  \
    static type  name##_mem[size];    \
    static tceu_pool name = { size, size, 0, sizeof(type), \
                             (char**)&name##_queue,        \
                             (char*) &name##_mem           \
                            } ;

void ceu_pool_init (tceu_pool* pool) {
    int i;
    for (i=0; i<pool->size; i++) {
        pool->queue[i] = &pool->mem[i*pool->unit];
    }
}

char* ceu_pool_alloc (tceu_pool* pool) {
    char* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, char* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

int ceu_pool_inside (tceu_pool* pool, char* val) {
    return ((char*)val >= pool->mem)
        && ((char*)val < pool->mem+(pool->size*pool->unit));
}

#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

#define CEU_NMEM       (=== CEU_NMEM ===)
#define CEU_NTRAILS    (9)

#ifdef CEU_IFCS
#include <stddef.h>
/* TODO: === direto? */
#define CEU_NCLS       (=== CEU_NCLS ===)
#endif

/* Macros that can be defined:
 * ceu_out_pending() (sync?)
 * ceu_out_wclock(dt)
 * ceu_out_event(id, len, data)
 * ceu_out_async(more?);
 * ceu_out_end(v)
*/

/*typedef === TCEU_NEVT === tceu_nevt;    // (x) number of events */
typedef u8 tceu_nevt;    /* (x) number of events */

/* TODO: lbl => unsigned */
typedef s8 tceu_nlbl;    /* (x) number of trails */

#ifdef CEU_IFCS
typedef === TCEU_NCLS === tceu_ncls;    /* (x) number of instances */
#endif

/* align all structs 1 byte
// TODO: verify defaults for microcontrollers
//#pragma pack(push)
//#pragma pack(1)
*/

#define CEU_MAX_STACK   255     /* TODO */

typedef union tceu_trl {
    tceu_nevt evt;
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
    };
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        u8        stk;
    };
#ifdef CEU_ORGS
    struct {
        tceu_nevt evt3;
        struct tceu_org* lnks;  /* TODO(ram): bad for alignment */
    };
#endif
} tceu_trl;

typedef union {
    int   v;
    void* ptr;
    s32   dt;
} tceu_evtp;

/* TODO(speed): hold nxt trl to run */
typedef struct {
    tceu_evtp evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    void*     evto;
#endif
#endif
    tceu_nevt evt;
} tceu_stk;

typedef struct {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

/* simulates an org prv/nxt */
typedef struct {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    u8 n;                   /* use for ands/fins                 */
    u8 lnk;
} tceu_lnk;

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    u8 n;                   /* number of trails (TODO: to metadata) */

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif

#ifdef CEU_NEWS
    u8 isDyn:  1;           /* created w/ new or spawn? */
    u8 toFree: 1;           /* free on termination? */
#endif
#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

#line 2

    int SDL_Rect_vs_Mouse (SDL_Rect* r, SDL_MouseButtonEvent* but) {
        return (but->x >= r->x) && (but->x <= r->x+r->w)
            && (but->y >= r->y) && (but->y <= r->y+r->h);
    }
#line 4

    int ORGS = 0;       // count the number of alive rectangles

typedef struct {
  struct tceu_org org;
  tceu_trl trls_[ 5 ];
  struct { /* BLOCK ln=41 */
    SDL_Rect rct;
    int vel;
    SDL_Renderer* ren;
    union {
      struct { /* BLOCK ln=46 */
      u8 __fin_423_1: 1;
        SDL_Color clr_4;
        int x_3;
        union {
              struct { /* BLOCK ln=54 */
                union {
                };
              };
          struct {
            struct { /* BLOCK ln=63 */
              union {
                  union {
                      s32 __wclk_367;
                    struct { /* BLOCK ln=64 */
                      union {
                          struct { /* BLOCK ln=66 */
                            union {
                            };
                          };
                          struct { /* BLOCK ln=71 */
                            union {
                            };
                          };
                      };
                    };
                  };
              };
            };
            struct { /* BLOCK ln=79 */
              s32 dt_5;
              float fx_6;
              union {
                  union {
                    struct { /* BLOCK ln=83 */
                      union {
                          struct { /* BLOCK ln=92 */
                            union {
                            };
                          };
                      };
                    };
                  };
              };
            };
            struct { /* BLOCK ln=97 */
              union {
                  union {
                    struct { /* BLOCK ln=98 */
                      union {
                      };
                    };
                  };
              };
            };
          };
        };
      };
    };
  };

} CEU_Rect;


#ifdef CEU_NEWS
CEU_POOL(CEU_POOL_Rect,CEU_Rect,10000);
#endif

typedef struct {
  struct tceu_org org;
  tceu_trl trls_[ 9 ];
  struct { /* BLOCK ln=1 */
    int _ret_0;
    union {
        struct { /* BLOCK ln=1 */
        u8 __fin_559_1: 1;
        u8 __fin_559_2: 1;
          SDL_Rect bg;
          int win_h;
          int win_w;
          SDL_Renderer* ren;
          SDL_Window* win;
          union {
            union {
            };
            union {
              union {
                    struct { /* BLOCK ln=18 */
                      union {
                      };
                    };
                    struct { /* BLOCK ln=27 */
                      union {
                      };
                    };
                struct {
                  struct { /* BLOCK ln=105 */
                    union {
                    };
                  };
                  struct { /* BLOCK ln=107 */
                    union {
                        union {
                          struct { /* BLOCK ln=108 */
                            union {
                            };
                          };
                        };
                    };
                  };
                  struct { /* BLOCK ln=112 */
                    union {
                        struct { /* BLOCK ln=113 */
                          union {
                            struct {
                              struct { /* BLOCK ln=114 */
                                union {
                                    s32 __wclk_442;
                                };
                              };
                              struct { /* BLOCK ln=116 */
                                union {
                                    struct { /* BLOCK ln=117 */
                                    tceu_lnk __lnks_506[2];
                                      union {
                                          union {
                                              s32 __wclk_502;
                                            struct { /* BLOCK ln=118 */
                                              union {
                                                struct { /* BLOCK ln=118 */
                                                  int i_6;
                                                  union {
                                                      union {
                                                        struct { /* BLOCK ln=119 */
                                                          union {
                                                                union {
                                                                };
                                                          };
                                                        };
                                                      };
                                                  };
                                                };
                                              };
                                            };
                                          };
                                      };
                                    };
                                };
                              };
                            };
                          };
                        };
                    };
                  };
                  struct { /* BLOCK ln=131 */
                    union {
                        struct { /* BLOCK ln=132 */
                          union {
                          };
                        };
                    };
                  };
                  struct { /* BLOCK ln=137 */
                    union {
                        struct { /* BLOCK ln=138 */
                          int c_7;
                          union {
                            struct {
                              struct { /* BLOCK ln=140 */
                                union {
                                    union {
                                      struct { /* BLOCK ln=141 */
                                        union {
                                        };
                                      };
                                    };
                                };
                              };
                              struct { /* BLOCK ln=144 */
                                union {
                                    s32 __wclk_542;
                                };
                              };
                            };
                          };
                        };
                    };
                  };
                };
                union {
                };
              };
            };
          };
        };
    };
  };

} CEU_Main;



enum {
    Rect_ParOr_sub_2_0 = 0,
    Rect_ParOr_sub_3_1 = 1,
    Rect_ParOr_out_2 = 2,
    Rect_Awake_DT_3 = 3,
    Rect_Loop_out_4 = 4,
    Rect_Awake_SDL_DT_5 = 5,
    Rect_Awake_SDL_REDRAW_6 = 6,
    Rect_Clear_7 = 7,
    Rect_Block__fin_8 = 8,
    Rect_Block_fin_cnt_9 = 9,
    Rect_Clear_10 = 10,
    Class_Rect = 11,
    Rect_Class_free_Rect_12 = 12,
    Main_Set_out_13 = 13,
    Main_ParOr_sub_2_14 = 14,
    Main_ParOr_sub_3_15 = 15,
    Main_ParOr_sub_4_16 = 16,
    Main_ParOr_sub_5_17 = 17,
    Main_ParOr_out_18 = 18,
    Main_Awake_SDL_QUIT_19 = 19,
    Main_Awake_SDL_REDRAW_20 = 20,
    Main_ParOr_sub_2_21 = 21,
    Main_ParOr_out_22 = 22,
    Main_Awake_DT_23 = 23,
    Main_Awake_DT_24 = 24,
    Main_Loop_out_25 = 25,
    Main_Spawn_cont_26 = 26,
    Main_Clear_27 = 27,
    Main_Clear_28 = 28,
    Main_Awake_SDL_REDRAW_29 = 29,
    Main_ParOr_sub_2_30 = 30,
    Main_ParOr_out_31 = 31,
    Main_Awake_SDL_REDRAW_32 = 32,
    Main_Awake_DT_33 = 33,
    Main_Clear_34 = 34,
    Main_Clear_35 = 35,
    Main_Block__fin_36 = 36,
    Main_Block_fin_cnt_37 = 37,
    Main_Clear_38 = 38,
    Main_Clear_39 = 39,
    Class_Main = 40,
    Main_Class_free_Main_41 = 41,

};

typedef struct {
#ifdef CEU_WCLOCKS
    int         wclk_late;
    s32         wclk_min;
    s32         wclk_min_tmp;
#endif

#ifdef CEU_IFCS
/* TODO: fun */
    u16   ifcs_flds[CEU_NCLS][=== IFCS_NFLDS ===];
    u16   ifcs_evts[CEU_NCLS][=== IFCS_NEVTS ===];
    void* ifcs_funs[CEU_NCLS][=== IFCS_NFUNS ===];
#endif

#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif

    CEU_Main    mem;
} tceu;

/* TODO: fields that need no initialization? */

tceu CEU = {
#ifdef CEU_WCLOCKS
    0, CEU_WCLOCK_INACTIVE, CEU_WCLOCK_INACTIVE,
#endif
#ifdef CEU_IFCS
    {
=== IFCS_FLDS ===
    },
    {
=== IFCS_EVTS ===
    },
    {
=== IFCS_FUNS ===
    },
#endif
#ifdef CEU_DEBUG
    {},
#endif
    {}                          /* TODO: o q ele gera? */
};

/*#pragma pack(pop) */

/**********************************************************************/

void ceu_go (int _ceu_evt, tceu_evtp _ceu_evtp);

/**********************************************************************/

#ifdef CEU_WCLOCKS

void ceu_wclocks_min (s32 dt, int out) {
    if (CEU.wclk_min > dt) {
        CEU.wclk_min = dt;
#ifdef ceu_out_wclock
        if (out)
            ceu_out_wclock(dt);
#endif
    }
}

int ceu_wclocks_expired (s32* t, s32 dt) {
    if (*t>CEU.wclk_min_tmp || *t>dt) {
        *t -= dt;
        ceu_wclocks_min(*t, 0);
        return 0;
    }
    return 1;
}

void ceu_trails_set_wclock (s32* t, s32 dt) {
    s32 dt_ = dt - CEU.wclk_late;
    *t = dt_;
    ceu_wclocks_min(dt_, 1);
}

#endif  /* CEU_WCLOCKS */

/**********************************************************************/

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
/* TODO */
int _ceu_dyns_ = 0;
#endif
#endif

/**********************************************************************/

#ifdef CEU_DEBUG
void ceu_segfault (int sig_num) {
#ifdef CEU_ORGS
    fprintf(stderr, "SEGFAULT on %p : %d\n", CEU.lst.org, CEU.lst.lbl);
#else
    fprintf(stderr, "SEGFAULT on %d\n", CEU.lst.lbl);
#endif
    exit(0);
}
#endif

/**********************************************************************/

void ceu_org_init (tceu_org* org, int n, int lbl, int seqno,
                   tceu_org* par_org, int par_trl)
{
    /* { evt=0, seqno=0, lbl=0 } for all trails */
#ifdef CEU_ORGS
    org->n = n;
#endif
    memset(&org->trls, 0, n*sizeof(tceu_trl));

    /* org.trls[0] == org.blk.trails[1] */
    org->trls[0].evt   = CEU_IN__STK;
    org->trls[0].lbl   = lbl;
    org->trls[0].seqno = seqno;

#ifdef CEU_ORGS
    if (par_org == NULL)
        return;             /* main class */

    /* re-link */
    {
        tceu_org* lst = &par_org->trls[par_trl].lnks[1];
        lst->prv->nxt = org;
        org->prv = lst->prv;
        org->nxt = lst;
        lst->prv = org;
    }
#endif  /* CEU_ORGS */
}
#ifndef CEU_ORGS
#define ceu_org_init(a,b,c,d,e,f) ceu_org_init(a,b,c,d,NULL,0)
#endif

/**********************************************************************/

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed) {
    do {
        if (psed) {
            if (trl->evt == CEU_IN__ORG)
                trl->evt = CEU_IN__ORG_PSED;
        } else {
            if (trl->evt == CEU_IN__ORG_PSED)
                trl->evt = CEU_IN__ORG;
        }
        if ( trl->evt == CEU_IN__ORG
        ||   trl->evt == CEU_IN__ORG_PSED ) {
            trl += 2;       /* jump [fst|lst] */
        }
    } while (++trl <= trlF);

#ifdef ceu_out_wclock
    if (!psed) {
        ceu_out_wclock(0);  /* TODO: recalculate MIN clock */
                            /*       between trl => trlF   */
    }
#endif
}
#endif

/**********************************************************************/

void ceu_go_init ()
{
#ifdef CEU_DEBUG
    signal(SIGSEGV, ceu_segfault);
#endif
#ifdef CEU_NEWS
    ceu_pool_init(&CEU_POOL_Rect);
#endif
    ceu_org_init((tceu_org*)&CEU.mem, CEU_NTRAILS, Class_Main, 0, NULL, 0);
    {
        tceu_evtp p;
        p.ptr = NULL;
        ceu_go(CEU_IN__INIT, p);
    }
}

/* TODO: ret */

#ifdef CEU_EXTS
void ceu_go_event (int id, void* data)
{
#ifdef CEU_DEBUG_TRAILS
    fprintf(stderr, "====== %d\n", id);
#endif
    {
        tceu_evtp p;
        p.ptr = data;
        ceu_go(id, p);
    }
}
#endif

#ifdef CEU_ASYNCS
void ceu_go_async ()
{
#ifdef CEU_DEBUG_TRAILS
    fprintf(stderr, "====== ASYNC\n");
#endif
    {
        tceu_evtp p;
        p.ptr = NULL;
        ceu_go(CEU_IN__ASYNC, p);
    }
}
#endif

void ceu_go_wclock (s32 dt)
{
#ifdef CEU_WCLOCKS

#ifdef CEU_DEBUG_TRAILS
    fprintf(stderr, "====== WCLOCK\n");
#endif

    if (CEU.wclk_min <= dt)
        CEU.wclk_late = dt - CEU.wclk_min;   /* how much late the wclock is */

    CEU.wclk_min_tmp = CEU.wclk_min;
    CEU.wclk_min     = CEU_WCLOCK_INACTIVE;

    {
        tceu_evtp p;
        p.dt = dt;
        ceu_go(CEU_IN__WCLOCK, p);
    }

#ifdef ceu_out_wclock
    if (CEU.wclk_min != CEU_WCLOCK_INACTIVE)
        ceu_out_wclock(CEU.wclk_min);   /* only signal after all */
#endif

    CEU.wclk_late = 0;

#endif   /* CEU_WCLOCKS */

    return;
}

void ceu_go_all (int* ret_end)
{
    ceu_go_init();
    if (ret_end!=NULL && *ret_end) goto _CEU_END_;

#ifdef CEU_IN_START
    ceu_go_event(CEU_IN_START, NULL);
    if (ret_end!=NULL && *ret_end) goto _CEU_END_;
#endif

#ifdef CEU_ASYNCS
    for (;;) {
        ceu_go_async();
        if (ret_end!=NULL && *ret_end) goto _CEU_END_;
    }
#endif

_CEU_END_:;
#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    #define CEU_MAX_DYNS 100
/*fprintf(stderr, "XXX %d\n", _ceu_dyns_); */
    assert(_ceu_dyns_ == 0);
#endif
#endif
}

#ifdef CEU_RUNTESTS
void ceu_stack_clr () {
    int a[1000];
    memset(a, 0, sizeof(a));
}
#endif

int ccc;
int CCC = 0;

void ceu_go (int _ceu_evt, tceu_evtp _ceu_evtp)
{
#ifdef CEU_ORGS
    tceu_org* _ceu_evto;       /* org that emitted current event */
#endif

#ifdef CEU_ORGS
    /* TODO: CEU_ORGS is calculable // CEU_NEWS isn't (255?) */
    tceu_stk _CEU_STK[CEU_MAX_STACK];
#else
    tceu_stk _CEU_STK[CEU_NTRAILS];
#endif

    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    static u8 _ceu_seqno = 0;

    /* current traversal state */
    int       _ceu_stki = 0;   /* points to next */
    tceu_trl* _ceu_trl;
    tceu_nlbl _ceu_lbl;
#ifdef CEU_ORGS
    tceu_org* _ceu_org;
#else
    #define   _ceu_org ((tceu_org*)&CEU.mem)
#endif

    /* traversals may be bounded to org/trl
     * default (NULL) is to traverse everything */
#ifdef CEU_CLEAR
    void* _ceu_stop = NULL;     /* stop at this trl/org */
#endif

    _ceu_seqno++;
    ccc = 0;

    for (;;)    /* STACK */
    {
#ifdef CEU_ORGS
        /* TODO: don't restart if kill is impossible (hold trl on stk) */
        _ceu_org = (tceu_org*) &CEU.mem;    /* on pop(), always restart */
#endif
#if defined(CEU_INTS) || defined(CEU_ORGS)
_CEU_CALL_:
#endif
        /* restart from org->trls[0] */
        _ceu_trl = &_ceu_org->trls[0];

#if defined(CEU_CLEAR) || defined(CEU_ORGS)
_CEU_CALLTRL_:  /* restart from org->trls[i] */
#endif

#ifdef CEU_DEBUG_TRAILS
#ifdef CEU_ORGS
fprintf(stderr, "GO[%d]: evt=%d stk=%d org=%p [%d/%p]\n", _ceu_seqno,
                _ceu_evt, _ceu_stki, _ceu_org, _ceu_org->n, _ceu_org->trls);
#else
fprintf(stderr, "GO[%d]: evt=%d stk=%d [%d]\n", _ceu_seqno,
                _ceu_evt, _ceu_stki, CEU_NTRAILS);
#endif
#endif
        for (;;) /* TRL // TODO(speed): only range of trails that apply */
        {        /* (e.g. events that do not escape an org) */
ccc++;
#ifdef CEU_CLEAR
            if (_ceu_trl == _ceu_stop) {    /* bounded trail traversal? */
                _ceu_stop = NULL;           /* back to default */
                break;                      /* pop stack */
            }
#endif

            /* _ceu_org has been traversed to the end? */
            if (_ceu_trl ==
                &_ceu_org->trls[
#ifdef CEU_ORGS
                    _ceu_org->n
#else
                    CEU_NTRAILS
#endif
                ])
            {
                if (_ceu_org == (tceu_org*) &CEU.mem) {
                    break;  /* pop stack */
                }

#ifdef CEU_ORGS
                {
                    /* hold next org/trl */
                    /* TODO(speed): jump LST */
                    tceu_org* _org = _ceu_org->nxt;
                    tceu_trl* _trl = &_org->trls [
                                        (_ceu_org->n == 0) ?
                                         ((tceu_lnk*)_ceu_org)->lnk : 0
                                      ];

#ifdef CEU_NEWS
                    /* org has been cleared to the end? */
                    if ( _ceu_evt  == CEU_IN__CLEAR
                    &&   _ceu_org->isDyn
                    &&   _ceu_org->n != 0 )  /* TODO: avoids LST */
                    {
                        /* re-link PRV <-> NXT */
                        _ceu_org->prv->nxt = _ceu_org->nxt;
                        _ceu_org->nxt->prv = _ceu_org->prv;

                        /* FREE */
                        {
                        /* TODO: check if needed? (freed manually?) */
                        /*fprintf(stderr, "FREE: %p\n", _ceu_org);*/
                                                if ( ceu_pool_inside(&CEU_POOL_Rect, (char*)_ceu_org) )
                    {
                        ceu_pool_free(&CEU_POOL_Rect, (char*)_ceu_org);
                    }
                    else
                        /* malloc in template.c */

                            /* else */
                            {
                                free(_ceu_org);
                            }
#ifdef CEU_RUNTESTS
                            _ceu_dyns_--;
#endif
                        }

                        /* explicit free(me) or end of spawn */
                        if (_ceu_stop == _ceu_org)
                            break;  /* pop stack */
                    }
#endif  /* CEU_NEWS */

                    _ceu_org = _org;
                    _ceu_trl = _trl;
/*fprintf(stderr, "UP[%p] %p %p\n", trl+1, _ceu_org _ceu_trl);*/
                    goto _CEU_CALLTRL_;
                }
#endif  /* CEU_ORGS */
            }

            /* continue traversing CUR org */
            {
#ifdef CEU_DEBUG_TRAILS
#ifdef CEU_ORGS
if (_ceu_trl->evt==CEU_IN__ORG)
    fprintf(stderr, "\tTRY [%p] : evt=%d org=?\n",
                    _ceu_trl, _ceu_trl->evt);
else
#endif
fprintf(stderr, "\tTRY [%p] : evt=%d seqno=%d lbl=%d\n",
                    _ceu_trl, _ceu_trl->evt, _ceu_trl->seqno, _ceu_trl->lbl);
#endif

                /* jump into linked orgs */
#ifdef CEU_ORGS
                if ( (_ceu_trl->evt == CEU_IN__ORG)
#ifdef CEU_PSES
                  || (_ceu_trl->evt==CEU_IN__ORG_PSED && _ceu_evt==CEU_IN__CLEAR)
#endif
                   )
                {
                    /* TODO(speed): jump LST */
                    _ceu_org = _ceu_trl->lnks[0].nxt;
                    if (_ceu_evt == CEU_IN__CLEAR) {
                        _ceu_trl->evt = CEU_IN__NONE;
                    }
                    goto _CEU_CALL_;
                }
#endif /* CEU_ORGS */

                switch (_ceu_evt)
                {
                    /* "clear" event */
                    case CEU_IN__CLEAR:
                        if (_ceu_trl->evt == CEU_IN__CLEAR)
                            goto _CEU_GO_;
                        _ceu_trl->evt = CEU_IN__NONE;
                        goto _CEU_NEXT_;
                }

                /* a continuation (STK) will always appear before a
                 * matched event in the same stack level
                 */
                if ( ! (
                    (_ceu_trl->evt==CEU_IN__STK && _ceu_trl->stk==_ceu_stki)
                ||
                    (_ceu_trl->evt==_ceu_evt    && _ceu_trl->seqno!=_ceu_seqno)
                    /* _ceu_evt!=CEU_IN__STK (never generated): comp is safe */
                    /* we use `!=Â´ intead of `<Â´ due to u8 overflow */
                ) ) {
                    goto _CEU_NEXT_;
                }
_CEU_GO_:
                /* execute this trail */
                _ceu_trl->evt   = CEU_IN__NONE;
                _ceu_trl->seqno = _ceu_seqno;   /* don't awake again */
                _ceu_lbl = _ceu_trl->lbl;
            }

#ifdef CEU_GOTO
_CEU_GOTO_:
#endif
#ifdef CEU_DEBUG
#ifdef CEU_ORG
    CEU.lst.org = _ceu_org;
#endif
    CEU.lst.trl = _ceu_trl;
    CEU.lst.lbl = _ceu_lbl;
#ifdef CEU_DEBUG_TRAILS
#ifdef CEU_ORGS
fprintf(stderr, "TRK: o.%p / l.%d\n", _ceu_org, _ceu_lbl);
#else
fprintf(stderr, "TRK: l.%d\n", _ceu_lbl);
#endif
#endif
#endif

#ifdef CEU_RUNTESTS
        ceu_stack_clr();
#endif

            switch (_ceu_lbl) {
                #line 41
case Class_Rect:;
#line 41
    #ifdef CEU_IFCS
_ceu_org->cls = 0;
#endif

#line 41
    {
#line 46
    /*  FINALIZE */
_ceu_org->trls[ 3 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 3 ].lbl = Rect_Block__fin_8;
_ceu_org->trls[ 3 ].stk = _ceu_seqno-1;    /* awake now */

#line 46
    ((CEU_Rect*)_ceu_org)->__fin_423_1 = 0;
#line 46
    {
#line 46
/* SET: . */
#line 46
    ((*((CEU_Rect*)_ceu_org)).rct.w) = 10;
#line 47
/* SET: . */
#line 47
    ((*((CEU_Rect*)_ceu_org)).rct.h) = 10;
#line 49
/* SET: x */
#line 49
    ((CEU_Rect*)_ceu_org)->x_3 = (((CEU_Rect*)_ceu_org)->rct.x);
#line 52
/* SET: _ORGS */
#line 52
    ORGS = (ORGS+1);
#line 53
    ((CEU_Rect*)_ceu_org)->__fin_423_1 = 1;
#line 58
/* SET: . */
#line 58
    (((CEU_Rect*)_ceu_org)->clr_4.r) = 0xFF;
#line 59
/* SET: . */
#line 59
    (((CEU_Rect*)_ceu_org)->clr_4.g) = 0xFF;
#line 60
/* SET: . */
#line 60
    (((CEU_Rect*)_ceu_org)->clr_4.b) = 0xFF;
#line 62
/* ParOr: spawn subs */
#line 62
    {
    tceu_trl* trl = &_ceu_org->trls[ 1 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Rect_ParOr_sub_2_0;
    trl->stk = _ceu_stki;
}

#line 62
    {
    tceu_trl* trl = &_ceu_org->trls[ 2 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Rect_ParOr_sub_3_1;
    trl->stk = _ceu_stki;
}

#line 63
    {
#line 63
    for (;;) {

#line 63
    ceu_trails_set_wclock(&((CEU_Rect*)_ceu_org)->__wclk_367, (s32)200000);
_CEU_NO_367_:
    _ceu_trl->evt = CEU_IN__WCLOCK;
    _ceu_trl->lbl = Rect_Awake_DT_3;

#line 63
    	goto _CEU_NEXT_;
#line 63
    case Rect_Awake_DT_3:;

#line 63
        if (!ceu_wclocks_expired(&((CEU_Rect*)_ceu_org)->__wclk_367, _ceu_evtp.dt) )
        goto _CEU_NO_367_;

#line 63
    #ifdef CEU_DEBUG_TRAILS
fprintf(stderr, "\tOK!\n");
#endif

#line 64
    {
#line 64
/* SET: . */
#line 64
    ((*((CEU_Rect*)_ceu_org)).rct.h) = (((((CEU_Rect*)_ceu_org)->rct.h)+(rand()%5))-2);
#line 65
    if (((((CEU_Rect*)_ceu_org)->rct.h)<=0)) {
#line 66
    {
#line 66
/* SET: . */
#line 66
    (((CEU_Rect*)_ceu_org)->rct.h) = 1;
#line 66
/* CLEAR: Block (66) */
#line 66
    }
#line 66
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 0 ]; */

} else {
}

#line 69
/* SET: . */
#line 69
    ((*((CEU_Rect*)_ceu_org)).rct.w) = (((((CEU_Rect*)_ceu_org)->rct.w)+(rand()%5))-2);
#line 70
    if (((((CEU_Rect*)_ceu_org)->rct.w)<=0)) {
#line 71
    {
#line 71
/* SET: . */
#line 71
    (((CEU_Rect*)_ceu_org)->rct.w) = 1;
#line 71
/* CLEAR: Block (71) */
#line 71
    }
#line 71
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 0 ]; */

} else {
}

#line 74
/* SET: . */
#line 74
    (((CEU_Rect*)_ceu_org)->clr_4.r) = (((((CEU_Rect*)_ceu_org)->clr_4.r)+(rand()%5))-2);
#line 75
/* SET: . */
#line 75
    (((CEU_Rect*)_ceu_org)->clr_4.g) = (((((CEU_Rect*)_ceu_org)->clr_4.g)+(rand()%5))-2);
#line 76
/* SET: . */
#line 76
    (((CEU_Rect*)_ceu_org)->clr_4.b) = (((((CEU_Rect*)_ceu_org)->clr_4.b)+(rand()%5))-2);
#line 64
/* CLEAR: Block (64) */
#line 64
    }
#line 64
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 0 ]; */

#line 63
    }

#line 63
/* CLEAR: Block (63) */
#line 63
    }
#line 62
case Rect_ParOr_sub_2_0:;
#line 79
    {
#line 80
/* SET: fx */
#line 80
    ((CEU_Rect*)_ceu_org)->fx_6 = ((CEU_Rect*)_ceu_org)->x_3;
#line 82
    for (;;) {

#line 82
        _ceu_trl->evt = CEU_IN_SDL_DT;
    _ceu_trl->lbl = Rect_Awake_SDL_DT_5;

#line 82
    	goto _CEU_NEXT_;
#line 82
    case Rect_Awake_SDL_DT_5:;

#line 82
    #ifdef CEU_DEBUG_TRAILS
fprintf(stderr, "\tOK!\n");
#endif

#line 82
    ((CEU_Rect*)_ceu_org)->dt_5 = *((int*)_ceu_evtp.ptr);
#line 83
    {
#line 83
/* SET: fx */
#line 83
    ((CEU_Rect*)_ceu_org)->fx_6 = (((CEU_Rect*)_ceu_org)->fx_6+(((float)((*((CEU_Rect*)_ceu_org)).vel*((CEU_Rect*)_ceu_org)->dt_5))/1000));
#line 84
/* SET: . */
#line 84
    (((CEU_Rect*)_ceu_org)->rct.x) = ((CEU_Rect*)_ceu_org)->fx_6;
#line 91
    if (((((CEU_Rect*)_ceu_org)->rct.x)>950)) {
#line 92
    {
#line 92
    break;
#line 92
/* CLEAR: Block (92) */
#line 92
    }
} else {
}

#line 83
/* CLEAR: Block (83) */
#line 83
    }
#line 83
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 1 ]; */

#line 82
    }

#line 82
/* CLEAR: Loop (82) */
#line 82
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_trl = &_ceu_org->trls[ 1 ];

#line 79
/* CLEAR: Block (79) */
#line 79
    }
#line 79
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 1 ]; */

#line 62
/* PAROR JOIN */
#line 62
    _ceu_lbl = Rect_ParOr_out_2;
goto _CEU_GOTO_;

#line 62
case Rect_ParOr_sub_3_1:;
#line 97
    {
#line 97
    for (;;) {

#line 97
        _ceu_trl->evt = CEU_IN_SDL_REDRAW;
    _ceu_trl->lbl = Rect_Awake_SDL_REDRAW_6;

#line 97
    	goto _CEU_NEXT_;
#line 97
    case Rect_Awake_SDL_REDRAW_6:;

#line 97
    #ifdef CEU_DEBUG_TRAILS
fprintf(stderr, "\tOK!\n");
#endif

#line 98
    {
#line 98
    SDL_SetRenderDrawColor(((CEU_Rect*)_ceu_org)->ren,(((CEU_Rect*)_ceu_org)->clr_4.r),(((CEU_Rect*)_ceu_org)->clr_4.g),(((CEU_Rect*)_ceu_org)->clr_4.b),0xFF);
#line 99
    SDL_RenderFillRect(((CEU_Rect*)_ceu_org)->ren,(&((CEU_Rect*)_ceu_org)->rct));
#line 98
/* CLEAR: Block (98) */
#line 98
    }
#line 98
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 2 ]; */

#line 97
    }

#line 97
/* CLEAR: Block (97) */
#line 97
    }
#line 62
case Rect_ParOr_out_2:;
#line 62
/* CLEAR: ParOr (62) */
#line 62
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_trl = &_ceu_org->trls[ 0 ];

#line 46
    _ceu_lbl = Rect_Block_fin_cnt_9;
goto _CEU_GOTO_;

#line 46
case Rect_Block__fin_8:;
#line 46
    if (((CEU_Rect*)_ceu_org)->__fin_423_1) {
#line 54
    {
#line 54
/* SET: _ORGS */
#line 54
    ORGS = (ORGS-1);
#line 54
/* CLEAR: Block (54) */
#line 54
    }
#line 54
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 0 ]; */

}

#line 46
    	goto _CEU_NEXT_;
#line 46
case Rect_Block_fin_cnt_9:;
#line 46
/* CLEAR: Block (46) */
#line 46
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_stki;
    trl->lbl = Rect_Clear_10;
}
_CEU_STK[_ceu_stki  ].evtp = _ceu_evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_CEU_STK[_ceu_stki  ].evto = _ceu_evto;
#endif
#endif
_CEU_STK[_ceu_stki++].evt  = _ceu_evt;

/* [ trails[1]+1, trails[2] [ */
_ceu_trl  = &_ceu_org->trls[ 1 ];
                                /* trails[1]+1 is in */
_ceu_stop = &_ceu_org->trls[ 4 ];
                                /* trails[2]+1 is out */
_ceu_evt = CEU_IN__CLEAR;
goto _CEU_CALLTRL_;

case Rect_Clear_10:;

#line 46
    }
#line 46
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 0 ]; */

#line 41
/* CLEAR: Block (41) */
#line 41
    }
#line 41
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 0 ]; */

#line 41
    #ifdef CEU_NEWS
if (_ceu_org->toFree) {

#line 41
    {
    tceu_org* __ceu_tofree = (tceu_org*) _ceu_org;
    if (__ceu_tofree != NULL)
    {
        /* TODO: assert isDyn */

#line 41
            /* clear all __ceu_tofree [ trls[0], ... [ */
        /* this will call free() */
        _ceu_stop = __ceu_tofree;
        _ceu_trl  = &__ceu_tofree->trls[0];

#line 41
            _CEU_STK[_ceu_stki  ].evtp = _ceu_evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
        _CEU_STK[_ceu_stki  ].evto = _ceu_evto;
#endif
#endif
        _CEU_STK[_ceu_stki++].evt  = _ceu_evt;

        _ceu_evt = CEU_IN__CLEAR;
        goto _CEU_CALLTRL_;
    }
}
case Rect_Class_free_Rect_12:;

#line 41
    }
#endif

#line 41
    	goto _CEU_NEXT_;
#line 1
case Class_Main:;
#line 1
    #ifdef CEU_IFCS
_ceu_org->cls = 1;
#endif

#line 1
    {
#line 1
    /*  FINALIZE */
_ceu_org->trls[ 8 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 8 ].lbl = Main_Block__fin_36;
_ceu_org->trls[ 8 ].stk = _ceu_seqno-1;    /* awake now */

#line 1
    ((CEU_Main*)_ceu_org)->__fin_559_1 = 0;
#line 1
    ((CEU_Main*)_ceu_org)->__fin_559_2 = 0;
#line 1
    {
#line 14
    ((CEU_Main*)_ceu_org)->__fin_559_2 = 1;
#line 15
/* SET: win */
#line 15
    ((CEU_Main*)_ceu_org)->win = SDL_CreateWindow("SDL 8",500,1300,1024,768,SDL_WINDOW_SHOWN);
#line 24
    ((CEU_Main*)_ceu_org)->__fin_559_1 = 1;
#line 25
/* SET: ren */
#line 25
    ((CEU_Main*)_ceu_org)->ren = SDL_CreateRenderer(((CEU_Main*)_ceu_org)->win,(-1),0);
#line 32
    SDL_GetWindowSize(((CEU_Main*)_ceu_org)->win,(&((CEU_Main*)_ceu_org)->win_w),(&((CEU_Main*)_ceu_org)->win_h));
#line 34
/* SET: . */
#line 34
    (((CEU_Main*)_ceu_org)->bg.w) = ((CEU_Main*)_ceu_org)->win_w;
#line 35
/* SET: . */
#line 35
    (((CEU_Main*)_ceu_org)->bg.h) = ((CEU_Main*)_ceu_org)->win_h;
#line 36
/* SET: . */
#line 36
    (((CEU_Main*)_ceu_org)->bg.x) = 0;
#line 37
/* SET: . */
#line 37
    (((CEU_Main*)_ceu_org)->bg.y) = 0;
#line 104
/* ParOr: spawn subs */
#line 104
    {
    tceu_trl* trl = &_ceu_org->trls[ 1 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Main_ParOr_sub_2_14;
    trl->stk = _ceu_stki;
}

#line 104
    {
    tceu_trl* trl = &_ceu_org->trls[ 2 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Main_ParOr_sub_3_15;
    trl->stk = _ceu_stki;
}

#line 104
    {
    tceu_trl* trl = &_ceu_org->trls[ 5 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Main_ParOr_sub_4_16;
    trl->stk = _ceu_stki;
}

#line 104
    {
    tceu_trl* trl = &_ceu_org->trls[ 6 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Main_ParOr_sub_5_17;
    trl->stk = _ceu_stki;
}

#line 105
    {
#line 105
        _ceu_trl->evt = CEU_IN_SDL_QUIT;
    _ceu_trl->lbl = Main_Awake_SDL_QUIT_19;

#line 105
    	goto _CEU_NEXT_;
#line 105
    case Main_Awake_SDL_QUIT_19:;

#line 105
    #ifdef CEU_DEBUG_TRAILS
fprintf(stderr, "\tOK!\n");
#endif

#line 105
/* CLEAR: Block (105) */
#line 105
    }
#line 105
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 0 ]; */

#line 104
/* PAROR JOIN */
#line 104
    _ceu_lbl = Main_ParOr_out_18;
goto _CEU_GOTO_;

#line 104
case Main_ParOr_sub_2_14:;
#line 107
    {
#line 107
    for (;;) {

#line 107
        _ceu_trl->evt = CEU_IN_SDL_REDRAW;
    _ceu_trl->lbl = Main_Awake_SDL_REDRAW_20;

#line 107
    	goto _CEU_NEXT_;
#line 107
    case Main_Awake_SDL_REDRAW_20:;

#line 107
    #ifdef CEU_DEBUG_TRAILS
fprintf(stderr, "\tOK!\n");
#endif

#line 108
    {
#line 108
    SDL_SetRenderDrawColor(((CEU_Main*)_ceu_org)->ren,0,0,0,0xFF);
#line 109
    SDL_RenderFillRect(((CEU_Main*)_ceu_org)->ren,(&((CEU_Main*)_ceu_org)->bg));
#line 108
/* CLEAR: Block (108) */
#line 108
    }
#line 108
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 1 ]; */

#line 107
    }

#line 107
/* CLEAR: Block (107) */
#line 107
    }
#line 104
case Main_ParOr_sub_3_15:;
#line 112
    {
#line 112
    for (;;) {

#line 113
    {
#line 113
/* ParOr: spawn subs */
#line 113
    {
    tceu_trl* trl = &_ceu_org->trls[ 3 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Main_ParOr_sub_2_21;
    trl->stk = _ceu_stki;
}

#line 114
    {
#line 114
    ceu_trails_set_wclock(&((CEU_Main*)_ceu_org)->__wclk_442, (s32)30000000);
_CEU_NO_442_:
    _ceu_trl->evt = CEU_IN__WCLOCK;
    _ceu_trl->lbl = Main_Awake_DT_23;

#line 114
    	goto _CEU_NEXT_;
#line 114
    case Main_Awake_DT_23:;

#line 114
        if (!ceu_wclocks_expired(&((CEU_Main*)_ceu_org)->__wclk_442, _ceu_evtp.dt) )
        goto _CEU_NO_442_;

#line 114
    #ifdef CEU_DEBUG_TRAILS
fprintf(stderr, "\tOK!\n");
#endif

#line 114
/* CLEAR: Block (114) */
#line 114
    }
#line 114
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 2 ]; */

#line 113
/* PAROR JOIN */
#line 113
    _ceu_lbl = Main_ParOr_out_22;
goto _CEU_GOTO_;

#line 113
case Main_ParOr_sub_2_21:;
#line 116
    {
#line 117
    _ceu_org->trls[ 4 ].evt  = CEU_IN__ORG;
_ceu_org->trls[ 4 ].lnks =
    (tceu_org*) &((CEU_Main*)_ceu_org)->__lnks_506;

((CEU_Main*)_ceu_org)->__lnks_506[0].nxt = (tceu_org*) &((CEU_Main*)_ceu_org)->__lnks_506[1];

((CEU_Main*)_ceu_org)->__lnks_506[1].prv = (tceu_org*) &((CEU_Main*)_ceu_org)->__lnks_506[0];
((CEU_Main*)_ceu_org)->__lnks_506[1].nxt =  _ceu_org;
((CEU_Main*)_ceu_org)->__lnks_506[1].n   =  0;
((CEU_Main*)_ceu_org)->__lnks_506[1].lnk =  4+1;

#line 117
    {
#line 117
    for (;;) {

#line 117
    ceu_trails_set_wclock(&((CEU_Main*)_ceu_org)->__wclk_502, (s32)40000);
_CEU_NO_502_:
    _ceu_trl->evt = CEU_IN__WCLOCK;
    _ceu_trl->lbl = Main_Awake_DT_24;

#line 117
    	goto _CEU_NEXT_;
#line 117
    case Main_Awake_DT_24:;

#line 117
        if (!ceu_wclocks_expired(&((CEU_Main*)_ceu_org)->__wclk_502, _ceu_evtp.dt) )
        goto _CEU_NO_502_;

#line 117
    #ifdef CEU_DEBUG_TRAILS
fprintf(stderr, "\tOK!\n");
#endif

#line 118
    {
#line 118
    {
#line 118
/* SET: i */
#line 118
    ((CEU_Main*)_ceu_org)->i_6 = 0;
#line 118
    for (;;) {

#line 118
    if ((((CEU_Main*)_ceu_org)->i_6>=30)) {
#line 118
    break;
} else {
}

#line 119
    {
#line 119
    {
    tceu_org* __ceu_new;

#line 119
        __ceu_new = (tceu_org*) ceu_pool_alloc(&CEU_POOL_Rect);

#line 119
    /*fprintf(stderr, "MALLOC: %p\n", __ceu_new); */
#ifdef CEU_RUNTESTS
    if (__ceu_new != NULL) {
        _ceu_dyns_++;
        if (_ceu_dyns_ > CEU_MAX_DYNS) {
            free(__ceu_new);
            __ceu_new = NULL;
            _ceu_dyns_--;
        }
    }
#endif

#line 119
        if (__ceu_new != NULL) {

#line 119
/* start org: dyn */
#line 119
    #ifdef CEU_NEWS
    ((tceu_org*) __ceu_new)->isDyn  = 1;
    ((tceu_org*) __ceu_new)->toFree = 1;
#endif

    /* resets org memory and starts org.trail[0]=Class_XXX */
    ceu_org_init(((tceu_org*) __ceu_new), 5,Class_Rect,
                _ceu_stki+1,    /* run now */
                _ceu_org, 4);

#line 119
    { tceu_org* __org = ((tceu_org*) __ceu_new);
#line 120
/* SET: . */
#line 120
    (*((CEU_Rect*)__org)).vel = (50+(rand()%20));
#line 121
/* SET: . */
#line 121
    ((*((CEU_Rect*)__org)).rct.x) = 50;
#line 122
/* SET: . */
#line 122
    ((*((CEU_Rect*)__org)).rct.y) = (rand()%750);
#line 123
/* SET: . */
#line 123
    (*((CEU_Rect*)__org)).ren = ((CEU_Main*)_ceu_org)->ren;
#line 119
    }
#line 119
        /* hold current blk trail: set to my continuation */
    _ceu_trl->evt = CEU_IN__STK;
    _ceu_trl->lbl = Main_Spawn_cont_26;
    _ceu_trl->stk = _ceu_stki;

    _CEU_STK[_ceu_stki  ].evtp = _ceu_evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
    _CEU_STK[_ceu_stki  ].evto = _ceu_evto;
#endif
#endif
    _CEU_STK[_ceu_stki++].evt  = _ceu_evt;

    /* switch to ORG */

    ((tceu_org*) __ceu_new)->trls[0].evt = CEU_IN__STK;
    ((tceu_org*) __ceu_new)->trls[0].lbl = Class_Rect;
    ((tceu_org*) __ceu_new)->trls[0].stk = _ceu_stki;

    _ceu_org  = ((tceu_org*) __ceu_new);
    _ceu_stop = &_ceu_org->trls[_ceu_org->n]; /* don't follow the up link */
    goto _CEU_CALL_;

case Main_Spawn_cont_26:;

#line 119
        }
}

#line 119
/* CLEAR: Block (119) */
#line 119
    }
#line 119
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 3 ]; */

#line 118
/* SET: i */
#line 118
    ((CEU_Main*)_ceu_org)->i_6 = (((CEU_Main*)_ceu_org)->i_6+1);
#line 118
    }

#line 118
/* CLEAR: Loop (118) */
#line 118
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_trl = &_ceu_org->trls[ 3 ];

#line 118
/* CLEAR: Block (118) */
#line 118
    }
#line 118
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 3 ]; */

#line 118
/* CLEAR: Block (118) */
#line 118
    }
#line 118
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 3 ]; */

#line 117
    }

#line 117
/* CLEAR: Block (117) */
#line 117
    }
#line 116
/* CLEAR: Block (116) */
#line 116
    }
#line 113
case Main_ParOr_out_22:;
#line 113
/* CLEAR: ParOr (113) */
#line 113
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_org->trls[ 2 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_stki;
    trl->lbl = Main_Clear_28;
}
_CEU_STK[_ceu_stki  ].evtp = _ceu_evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_CEU_STK[_ceu_stki  ].evto = _ceu_evto;
#endif
#endif
_CEU_STK[_ceu_stki++].evt  = _ceu_evt;

/* [ trails[1]+1, trails[2] [ */
_ceu_trl  = &_ceu_org->trls[ 3 ];
                                /* trails[1]+1 is in */
_ceu_stop = &_ceu_org->trls[ 5 ];
                                /* trails[2]+1 is out */
_ceu_evt = CEU_IN__CLEAR;
goto _CEU_CALLTRL_;

case Main_Clear_28:;

#line 113
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_trl = &_ceu_org->trls[ 2 ];

#line 113
/* CLEAR: Block (113) */
#line 113
    }
#line 113
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 2 ]; */

#line 112
    }

#line 112
/* CLEAR: Block (112) */
#line 112
    }
#line 104
case Main_ParOr_sub_4_16:;
#line 131
    {
#line 131
    for (;;) {

#line 132
    {
#line 132
        _ceu_trl->evt = CEU_IN_SDL_REDRAW;
    _ceu_trl->lbl = Main_Awake_SDL_REDRAW_29;

#line 132
    	goto _CEU_NEXT_;
#line 132
    case Main_Awake_SDL_REDRAW_29:;

#line 132
    #ifdef CEU_DEBUG_TRAILS
fprintf(stderr, "\tOK!\n");
#endif

#line 133
    SDL_RenderPresent(((CEU_Main*)_ceu_org)->ren);
#line 132
/* CLEAR: Block (132) */
#line 132
    }
#line 132
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 5 ]; */

#line 131
    }

#line 131
/* CLEAR: Block (131) */
#line 131
    }
#line 104
case Main_ParOr_sub_5_17:;
#line 137
    {
#line 137
    for (;;) {

#line 138
    {
#line 138
/* SET: c */
#line 138
    ((CEU_Main*)_ceu_org)->c_7 = 0;
#line 139
/* ParOr: spawn subs */
#line 139
    {
    tceu_trl* trl = &_ceu_org->trls[ 7 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Main_ParOr_sub_2_30;
    trl->stk = _ceu_stki;
}

#line 140
    {
#line 140
    for (;;) {

#line 140
        _ceu_trl->evt = CEU_IN_SDL_REDRAW;
    _ceu_trl->lbl = Main_Awake_SDL_REDRAW_32;

#line 140
    	goto _CEU_NEXT_;
#line 140
    case Main_Awake_SDL_REDRAW_32:;

#line 140
    #ifdef CEU_DEBUG_TRAILS
fprintf(stderr, "\tOK!\n");
#endif

#line 141
    {
#line 141
/* SET: c */
#line 141
    ((CEU_Main*)_ceu_org)->c_7 = (((CEU_Main*)_ceu_org)->c_7+1);
#line 141
/* CLEAR: Block (141) */
#line 141
    }
#line 141
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 6 ]; */

#line 140
    }

#line 140
/* CLEAR: Block (140) */
#line 140
    }
#line 139
case Main_ParOr_sub_2_30:;
#line 144
    {
#line 144
    ceu_trails_set_wclock(&((CEU_Main*)_ceu_org)->__wclk_542, (s32)1000000);
_CEU_NO_542_:
    _ceu_trl->evt = CEU_IN__WCLOCK;
    _ceu_trl->lbl = Main_Awake_DT_33;

#line 144
    	goto _CEU_NEXT_;
#line 144
    case Main_Awake_DT_33:;

#line 144
        if (!ceu_wclocks_expired(&((CEU_Main*)_ceu_org)->__wclk_542, _ceu_evtp.dt) )
        goto _CEU_NO_542_;

#line 144
    #ifdef CEU_DEBUG_TRAILS
fprintf(stderr, "\tOK!\n");
#endif

#line 144
/* CLEAR: Block (144) */
#line 144
    }
#line 144
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 7 ]; */

#line 139
/* PAROR JOIN */
#line 139
    _ceu_lbl = Main_ParOr_out_31;
goto _CEU_GOTO_;

#line 139
case Main_ParOr_out_31:;
#line 139
/* CLEAR: ParOr (139) */
#line 139
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_org->trls[ 6 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_stki;
    trl->lbl = Main_Clear_34;
}
_CEU_STK[_ceu_stki  ].evtp = _ceu_evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_CEU_STK[_ceu_stki  ].evto = _ceu_evto;
#endif
#endif
_CEU_STK[_ceu_stki++].evt  = _ceu_evt;

/* [ trails[1]+1, trails[2] [ */
_ceu_trl  = &_ceu_org->trls[ 7 ];
                                /* trails[1]+1 is in */
_ceu_stop = &_ceu_org->trls[ 8 ];
                                /* trails[2]+1 is out */
_ceu_evt = CEU_IN__CLEAR;
goto _CEU_CALLTRL_;

case Main_Clear_34:;

#line 139
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_trl = &_ceu_org->trls[ 6 ];

#line 146
    printf("[FPS=%d] [orgs=%d]\n",((CEU_Main*)_ceu_org)->c_7,ORGS);
#line 138
/* CLEAR: Block (138) */
#line 138
    }
#line 138
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 6 ]; */

#line 137
    }

#line 137
/* CLEAR: Block (137) */
#line 137
    }
#line 104
case Main_ParOr_out_18:;
#line 104
/* CLEAR: ParOr (104) */
#line 104
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_stki;
    trl->lbl = Main_Clear_35;
}
_CEU_STK[_ceu_stki  ].evtp = _ceu_evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_CEU_STK[_ceu_stki  ].evto = _ceu_evto;
#endif
#endif
_CEU_STK[_ceu_stki++].evt  = _ceu_evt;

/* [ trails[1]+1, trails[2] [ */
_ceu_trl  = &_ceu_org->trls[ 1 ];
                                /* trails[1]+1 is in */
_ceu_stop = &_ceu_org->trls[ 8 ];
                                /* trails[2]+1 is out */
_ceu_evt = CEU_IN__CLEAR;
goto _CEU_CALLTRL_;

case Main_Clear_35:;

#line 104
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_trl = &_ceu_org->trls[ 0 ];

#line 150
/* SET: _ret */
#line 150
    ((CEU_Main*)_ceu_org)->_ret_0 = 0;
#line 150
    #ifdef ceu_out_end
    ceu_out_end(((CEU_Main*)_ceu_org)->_ret_0);
#endif

#line 150
    _ceu_lbl = Main_Set_out_13;
goto _CEU_GOTO_;

#line 1
    _ceu_lbl = Main_Block_fin_cnt_37;
goto _CEU_GOTO_;

#line 1
case Main_Block__fin_36:;
#line 1
    if (((CEU_Main*)_ceu_org)->__fin_559_1) {
#line 27
    {
#line 27
    SDL_DestroyRenderer(((CEU_Main*)_ceu_org)->ren);
#line 27
/* CLEAR: Block (27) */
#line 27
    }
#line 27
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 0 ]; */

}

#line 1
    if (((CEU_Main*)_ceu_org)->__fin_559_2) {
#line 18
    {
#line 18
    SDL_DestroyWindow(((CEU_Main*)_ceu_org)->win);
#line 18
/* CLEAR: Block (18) */
#line 18
    }
#line 18
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 0 ]; */

}

#line 1
    	goto _CEU_NEXT_;
#line 1
case Main_Block_fin_cnt_37:;
#line 1
/* CLEAR: Block (1) */
#line 1
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_stki;
    trl->lbl = Main_Clear_38;
}
_CEU_STK[_ceu_stki  ].evtp = _ceu_evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_CEU_STK[_ceu_stki  ].evto = _ceu_evto;
#endif
#endif
_CEU_STK[_ceu_stki++].evt  = _ceu_evt;

/* [ trails[1]+1, trails[2] [ */
_ceu_trl  = &_ceu_org->trls[ 1 ];
                                /* trails[1]+1 is in */
_ceu_stop = &_ceu_org->trls[ 9 ];
                                /* trails[2]+1 is out */
_ceu_evt = CEU_IN__CLEAR;
goto _CEU_CALLTRL_;

case Main_Clear_38:;

#line 1
    }
#line 1
    	goto _CEU_NEXT_;
#line 1
case Main_Set_out_13:;
#line 1
/* CLEAR: SetBlock (1) */
#line 1
    /* trails[1] points to ORG blk */
{
    tceu_trl* trl = &_ceu_org->trls[ 0 ];
    trl->evt = CEU_IN__STK;
    trl->stk = _ceu_stki;
    trl->lbl = Main_Clear_39;
}
_CEU_STK[_ceu_stki  ].evtp = _ceu_evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
_CEU_STK[_ceu_stki  ].evto = _ceu_evto;
#endif
#endif
_CEU_STK[_ceu_stki++].evt  = _ceu_evt;

/* [ trails[1]+1, trails[2] [ */
_ceu_trl  = &_ceu_org->trls[ 1 ];
                                /* trails[1]+1 is in */
_ceu_stop = &_ceu_org->trls[ 9 ];
                                /* trails[2]+1 is out */
_ceu_evt = CEU_IN__CLEAR;
goto _CEU_CALLTRL_;

case Main_Clear_39:;

#line 1
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_ceu_trl = &_ceu_org->trls[ 0 ];

#line 1
/* CLEAR: Block (1) */
#line 1
    }
#line 1
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
/*_ceu_trl = &_ceu_org->trls[ 0 ]; */

#line 1
    #ifdef CEU_NEWS
if (_ceu_org->toFree) {

#line 1
    {
    tceu_org* __ceu_tofree = (tceu_org*) _ceu_org;
    if (__ceu_tofree != NULL)
    {
        /* TODO: assert isDyn */

#line 1
            /* clear all __ceu_tofree [ trls[0], ... [ */
        /* this will call free() */
        _ceu_stop = __ceu_tofree;
        _ceu_trl  = &__ceu_tofree->trls[0];

#line 1
            _CEU_STK[_ceu_stki  ].evtp = _ceu_evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
        _CEU_STK[_ceu_stki  ].evto = _ceu_evto;
#endif
#endif
        _CEU_STK[_ceu_stki++].evt  = _ceu_evt;

        _ceu_evt = CEU_IN__CLEAR;
        goto _CEU_CALLTRL_;
    }
}
case Main_Class_free_Main_41:;

#line 1
    }
#endif

#line 1
    	goto _CEU_NEXT_;

            }
_CEU_NEXT_:
            /* _ceu_trl!=CEU_IN__ORG guaranteed here */
            if (_ceu_trl->evt!=CEU_IN__STK && _ceu_trl->seqno!=_ceu_seqno)
                _ceu_trl->seqno = _ceu_seqno-1;   /* keeps the gap tight */
            _ceu_trl++;
        }

        if (_ceu_stki == 0) {
            break;      /* reaction has terminated */
        }
        _ceu_evtp = _CEU_STK[--_ceu_stki].evtp;
#ifdef CEU_INTS
#ifdef CEU_ORGS
        _ceu_evto = _CEU_STK[  _ceu_stki].evto;
#endif
#endif
        _ceu_evt  = _CEU_STK[  _ceu_stki].evt;
    }
CCC = (ccc > CCC) ? ccc : CCC;
}
#ifdef __ANDROID__
int SDL_main (int argc, char *argv[])
#else
int main (int argc, char *argv[])
#endif
{
    SDL_Init(SDL_INIT_EVERYTHING);

#ifdef CEU_IN_SDL_DT
    WCLOCK_nxt = 20000;
#else
    WCLOCK_nxt = CEU_WCLOCK_INACTIVE;
#endif

#if defined(CEU_WCLOCKS) || defined(CEU_IN_SDL_DT)
    u32 old = SDL_GetTicks();
#endif

    ceu_go_init();
    if (ret) goto END;

// TODO: push START into queue
#ifdef CEU_IN_START
    ceu_go_event(CEU_IN_START, NULL);
    if (ret) goto END;
#endif
#ifdef CEU_IN_SDL_REDRAW
    ceu_go_event(CEU_IN_SDL_REDRAW, NULL);
    if (ret) goto END;
#endif

    SDL_Event evt;
    for (;;)
    {
#ifndef SDL_SIMUL

#ifdef CEU_IN_SDL_DT
        s32 tm = 0;
#else
        s32 tm = -1;
#ifdef CEU_WCLOCKS
        if (WCLOCK_nxt != CEU_WCLOCK_INACTIVE)
            tm = WCLOCK_nxt / 1000;
#endif
#ifdef CEU_ASYNCS
        if (ASYNC_nxt)
            tm = 0;
#endif
#endif  // CEU_IN_SDL_DT

        int has = SDL_WaitEventTimeout(&evt, tm);

#if defined(CEU_WCLOCKS) || defined(CEU_IN_SDL_DT)
        u32 now = SDL_GetTicks();
        s32 dt = now - old;
        old = now;
#endif

#ifdef CEU_WCLOCKS
        if (WCLOCK_nxt != CEU_WCLOCK_INACTIVE) {
            ceu_go_wclock(1000*dt);
            if (ret) goto END;
            while (WCLOCK_nxt <= 0) {
                ceu_go_wclock(0);
                if (ret) goto END;
            }
        }
#endif

#ifdef CEU_IN_SDL_DT
        ceu_go_event(CEU_IN_SDL_DT, &dt);
        if (ret) goto END;
#endif

        // OTHER EVENTS
        if (has)
        {
//printf("EVT: %x\n", evt.type);
            switch (evt.type) {
#ifdef CEU_IN_SDL_QUIT
                case SDL_QUIT:
                    ceu_go_event(CEU_IN_SDL_QUIT, NULL);
                    break;
#endif
#ifdef CEU_IN_SDL_WINDOWEVENT
                case SDL_WINDOWEVENT:
                    ceu_go_event(CEU_IN_SDL_WINDOWEVENT, &evt);
                    break;
#endif
#ifdef CEU_IN_SDL_KEYDOWN
                case SDL_KEYDOWN:
                    ceu_go_event(CEU_IN_SDL_KEYDOWN, &evt);
                    break;
#endif
#ifdef CEU_IN_SDL_KEYUP
                case SDL_KEYUP:
                    ceu_go_event(CEU_IN_SDL_KEYUP, &evt);
                    break;
#endif
#ifdef CEU_IN_SDL_TEXTINPUT
                case SDL_TEXTINPUT:
                    ceu_go_event(CEU_IN_SDL_TEXTINPUT, &evt);
                    break;
#endif
#ifdef CEU_IN_SDL_TEXTEDITING
                case SDL_TEXTEDITING:
                    ceu_go_event(CEU_IN_SDL_TEXTEDITING, &evt);
                    break;
#endif
#ifdef CEU_IN_SDL_MOUSEMOTION
                case SDL_MOUSEMOTION:
                    ceu_go_event(CEU_IN_SDL_MOUSEMOTION, &evt);
                    break;
#endif
#ifdef CEU_IN_SDL_MOUSEBUTTONDOWN
                case SDL_MOUSEBUTTONDOWN:
                    ceu_go_event(CEU_IN_SDL_MOUSEBUTTONDOWN, &evt);
                    break;
#endif
#ifdef CEU_IN_SDL_MOUSEBUTTONUP
                case SDL_MOUSEBUTTONUP:
                    ceu_go_event(CEU_IN_SDL_MOUSEBUTTONUP, &evt);
                    break;
#endif
#ifdef CEU_IN_SDL_FINGERDOWN
                case SDL_FINGERDOWN:
                    ceu_go_event(CEU_IN_SDL_FINGERDOWN, &evt);
                    break;
#endif
#ifdef CEU_IN_SDL_FINGERUP
                case SDL_FINGERUP:
                    ceu_go_event(CEU_IN_SDL_FINGERUP, &evt);
                    break;
#endif
            }
            if (ret) goto END;
        }

#ifdef CEU_IN_SDL_REDRAW
        ceu_go_event(CEU_IN_SDL_REDRAW, NULL);
        if (ret) goto END;
#endif

#endif  // SDL_SIMUL

#ifdef CEU_ASYNCS
        if (ASYNC_nxt) {
            ceu_go_async(NULL);
            if (ret) goto END;
        }
#endif
    }
END:
    SDL_Quit();         // TODO: slow
    return ret_val;
}

