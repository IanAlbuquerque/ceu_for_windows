#ifndef ALL
    #include "sdl.ceu"

native do
    float abs_float(float x)
    {
        return x<0?-x:x;
    }
end

//============================================================

    #define PI 3.14
    #define WINDOW_TITLE "Hero Brawler"
    #define RES_X 640
    #define RES_Y 480
    #define GRAVITY 5.0
    #define FLOAT_ERR 0.03

//============================================================

    input void SDL_QUIT;
    input void SDL_REDRAW;
    input int  SDL_DT;

//============================================================

    input _SDL_KeyboardEvent* SDL_KEYDOWN;
    input _SDL_KeyboardEvent* SDL_KEYUP;

//============================================================

    var _SDL_Window[] win;
    finalize
        win = _SDL_CreateWindow(WINDOW_TITLE, 100,100, RES_X, RES_Y, 0);
    with
        _SDL_DestroyWindow(win);
    end

    var _SDL_Renderer[] ren;
    finalize
        ren = _SDL_CreateRenderer(win, -1, 0);
    with
        _SDL_DestroyRenderer(ren);
    end
#else
    _SDL_SetWindowTitle(win, WINDOW_TITLE);
#endif

//============================================================

native do
    SDL_Texture* HERO_TEXTURE;
end
    finalize
        _HERO_TEXTURE = _IMG_LoadTexture(ren, "charmander.png");
    with
        _SDL_DestroyTexture(_HERO_TEXTURE);
    end

    if _HERO_TEXTURE == null then
        _printf("SDL_Init failed: %s\n", _SDL_GetError());
    end

//============================================================

interface Position with
    var float pos_x;
    var float pos_y;
end

interface Speed with
    var float spd_x;
    var float spd_y;
end

interface Acceleration with
    var float acc_x;
    var float acc_y;
end

//============================================================

interface Body with
    interface Position;
    interface Speed;
    interface Acceleration; 
end

interface SquareDimensions with
    var float w;
    var float h;
end

//============================================================


class Platform with
    var _SDL_Renderer[] ren;

    interface Position;
    interface SquareDimensions;

    event void go_collide;
    event void un_collide;
do
    var _SDL_Rect rect;
    var int r = 0x00;
    var int g = 0x00;
    var int b = 0x00;

    par do
        loop do
            await go_collide;
            r = 0xFF;
        end 
    with
        loop do
            await un_collide;
            r = 0x00;
        end 
    with
        every SDL_REDRAW do
            this.rect.x = pos_x * RES_X;
            this.rect.y = pos_y * RES_Y;
            this.rect.w = w * RES_X;
            this.rect.h = h * RES_Y;
            _SDL_SetRenderDrawColor(ren, r, g, b, 0xFF);
            _SDL_RenderFillRect(ren, &rect);
        end
    end
end

class Hero with
    var _SDL_Renderer[] ren;

    interface Body;
    interface SquareDimensions;
    event int go_collide;
    event void die;

    var float hp;
do
    var bool walk_l = false;
    var bool walk_r = false;
    var _SDL_Rect rect;
    var _SDL_Texture[] tex = _HERO_TEXTURE;

    this.spd_x = 0;
    this.spd_y = 0;
    this.acc_x = 0;
    this.acc_y = 0;

    var int jumps_max = 2;
    var int jumps_ready = jumps_max;

    par do
        var int dt_ms;
        var float dt_s;
        every dt_ms in SDL_DT do
            dt_s = dt_ms/1000.0;

            this.pos_x = this.pos_x + this.spd_x * dt_s;
            this.pos_y = this.pos_y + this.spd_y * dt_s;

            this.spd_x = this.spd_x + this.acc_x * dt_s;
            this.spd_y = this.spd_y + this.acc_y * dt_s;
        end
    with
        var int dt_ms;
        var float dt_s;
        every dt_ms in SDL_DT do
            dt_s = dt_ms/1000.0;

            this.spd_y = this.spd_y + GRAVITY * dt_s;
        end
    with
        var int plat_y;
        loop do
            plat_y = await go_collide;
            this.spd_y = 0;
            this.pos_y = (float) plat_y / RES_Y - this.h;
            jumps_ready = jumps_max;
        end
    with
        loop do
            await die;
            this.pos_x = 0.5;
            this.pos_y = 0.0;
            this.spd_x = 0;
            this.spd_y = 0;
            this.acc_x = 0;
            this.acc_y = 0;
            jumps_ready = 0;
        end
    with
        var int dt_ms;
        var float dt_s;
        every dt_ms in SDL_DT do
            dt_s = dt_ms/1000.0;

            if walk_l == true then
                this.pos_x = this.pos_x + (-0.4) * dt_s;
            end
            if walk_r == true then
                this.pos_x = this.pos_x + (0.4) * dt_s;
            end
        end
    with
        var _SDL_KeyboardEvent* key;
        every key in SDL_KEYDOWN do
            if key:keysym.sym == _SDLK_UP then
            else/if key:keysym.sym == _SDLK_LEFT then
                walk_l = true;
            else/if key:keysym.sym == _SDLK_RIGHT then
                walk_r = true;
            end
        end
    with
        var _SDL_KeyboardEvent* key;
        loop do
            key = await SDL_KEYDOWN;
            if key:keysym.sym == _SDLK_UP then
                if jumps_ready > 0 then
                    this.spd_y = -1.5;
                    jumps_ready = jumps_ready - 1;
                    await 200ms;
                end
            end
        end
    with
        var _SDL_KeyboardEvent* key;
        every key in SDL_KEYUP do
            if key:keysym.sym == _SDLK_UP then
               // this.spd_y = 0;
            else/if key:keysym.sym == _SDLK_DOWN then
               // this.spd_y = 0;
            else/if key:keysym.sym == _SDLK_LEFT then
                walk_l = false;
            else/if key:keysym.sym == _SDLK_RIGHT then
                walk_r = false;
            end
        end
    with
        every SDL_REDRAW do
            this.rect.x = pos_x * RES_X;
            this.rect.y = pos_y * RES_Y;
            this.rect.w = w * RES_X;
            this.rect.h = h * RES_Y;
            _SDL_RenderCopy(ren, tex, null, &rect);
        end
    end

end

//============================================================

par/or do
    every SDL_REDRAW do
        _SDL_SetRenderDrawColor(ren, 0xAA, 0xAA, 0xAA, 0);
        _SDL_RenderFillRect(ren, null);
    end
with
    var Hero charmander with
        this.ren = ren;
        this.pos_x = 0.2;
        this.pos_y = 0.5;
        this.w  = 0.10;
        this.h  = this.w * RES_X / RES_Y;
    end;

    pool Platform[] platforms;
    spawn Platform in platforms with
        this.ren = ren;
        this.pos_x = 0.15;
        this.pos_y = 0.65;
        this.w  = 0.25;
        this.h  = 0.05;
    end;
    spawn Platform in platforms with
        this.ren = ren;
        this.pos_x = 0.55;
        this.pos_y = 0.45;
        this.w  = 0.25;
        this.h  = 0.05;
    end;
    spawn Platform in platforms with
        this.ren = ren;
        this.pos_x = 0.1;
        this.pos_y = 0.90;
        this.w  = 0.8;
        this.h  = 0.05;
    end;

    every SDL_DT do
        loop (Platform*)plat in platforms do
            if charmander.pos_x + charmander.w >= plat:pos_x and 
                charmander.pos_x <= plat:pos_x + plat:w and 
                _abs_float(charmander.pos_y + charmander.h - plat:pos_y) <= FLOAT_ERR and
                charmander.spd_y > 0 then

                emit charmander.go_collide => plat:pos_y * RES_Y;
                emit plat:go_collide;
            else
                emit plat:un_collide;
            end
        end

        if charmander.pos_y >= 1.0 then
            emit charmander.die;
        end
    end
with
    every SDL_REDRAW do
        _SDL_RenderPresent(ren);
    end
with
    await SDL_QUIT;
end

escape 0;
